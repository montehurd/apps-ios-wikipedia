
<!doctype html>
<meta charset=utf8>
<meta name="viewport" id="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
<script src="resources/lib/codemirror/lib/codemirror.js"></script>
<link rel=stylesheet href="resources/lib/codemirror/lib/codemirror.css">
<script src="resources/mode/mediawiki/mediawiki.js"></script>
<link rel=stylesheet href="resources/mode/mediawiki/mediawiki.css">

<style>
  
  body {
    margin: 0;
  }
  
  .CodeMirror, textarea#editor {
    height: 100vh;
    width: 100%;
    -webkit-overflow-scrolling: touch;
    box-sizing: border-box;
  }
  
  textarea#editor {
    padding: 4px;
    border: none;
    font-family: monospace;
    font-size: 13px;
  }
  
</style>

<body>
  
  <textarea id=editor></textarea>


  <!--TODO: load config by lang as needed-->
  <script>
  let config
  </script>
  <script src="codemirror-config.js" ></script>


  <script>

    let editor
    let editorTextArea = document.getElementById("editor")
    
    let codeMirrorSettings = {
      mwConfig: config,
      lineWrapping: true,
      lineNumbers: true,
      mode: "text/mediawiki",
      matchBrackets: true,
      extraKeys: {
        // t.b.d.
      }, 
      inputStyle: 'contenteditable',
      spellcheck: false,
      viewportMargin: Infinity
    }

    const EditorType = {
      notset: 0,
      codemirror: 1,
      wikitext: 2
    }

    let currentEditorType = EditorType.notset

    const showWikitext = () => {
      editor.toTextArea()
      editorTextArea.style.display = 'block'
      currentEditorType = EditorType.wikitext
    }

    const rangesIntersect = (range1, range2) => {
      if (range1.start > range2.start + (range2.end - range2.start)) return false
      if (range2.start > range1.start + (range1.end - range1.start)) return false
      return true

// const x1 = range1.start
// const y1 = range1.end
// 
// const x2 = range2.start
// const y2 = range2.end
// 
// const overlap = ( x2 > y1 || y2 < x1 ) ? 0 : (y2 >= y1 && x2 <= y1 ? y1 : y2) - ( x2 <= x1 && y2 >= x1 ? x1 : x2) + 1; //max 11 operations
// return overlap > 0
    }



// const rangesIntersect2 = (range1, range2) => {
//   if (range1.start > range2.start + (range2.end - range2.start)) return false
//   if (range2.start > range1.start + (range1.end - range1.start)) return false
//   return true
// }




// TODO: make explicit class for this selection range info!
    const getSelectionRange = (doc) => {
      const fromCursor = doc.getCursor('from')
      const toCursor = doc.getCursor('to')
      return {
        start: fromCursor.ch,
        end: toCursor.ch,
        isSingleLine: (fromCursor.line === toCursor.line),
        line: fromCursor.line,
        selection: doc.getSelection()
      }
    }
    
    const tokensIntersectingSelection = (selectionRange, lineTokens) => {
      return lineTokens
        .filter(token => {
          return rangesIntersect(selectionRange, token)
        })
    }

    const buttonPayload = (buttonName, buttonInfoDict) => {
      return {button: buttonName, info: buttonInfoDict}
    } 

    // returns zero if `string` is not comprised only of `char`.
    // else returns length of `string`
    const charCountInString = (string, char) => {
      const matches = string.match(`^${char}+$`)
      return (matches === null) ? 0 : string.length
    }

    const numberFromPrefixedKey = (array, prefix) => {
      const s = array.find(s => s.startsWith(prefix))
      if (!s) {
        return null
      }
      return parseInt(s.substring(prefix.length))
    }

    // The wikitext parser doesn't add a useful classes for some wikitext constructs, so supplement 
    // these here. Makes it easier to determine when the cursor sits in such wikitext (or it's
    // selected) with the same mechanism (token 'type' inspection).
    const enrichedLineTokens = (doc, line) => {
      const lineTokens = doc.getLineTokens(line, true)

      enrichHeadingTokens(lineTokens)      
      enrichListTokens(lineTokens)
      enrichIndentTokens(lineTokens)
      enrichSignatureTokens(lineTokens)
      
      return lineTokens
    }

    const tokenIncludesType = (token, type) => {
      return (token.type === null) ? false : token.type.split(' ').includes(type)
    }

    const indexOfFirstLineTokenWithType = (lineTokens, type) => {
      return lineTokens.findIndex(token => {
        return tokenIncludesType(token, type)
      })
    }

    // Adds missing classes to heading contents.
    const enrichHeadingTokens = (lineTokens) => {
      const headingTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-section-header')
      const headingContentsTokenIndex = headingTokenIndex + 1
      const headingContentsTokenExists = headingContentsTokenIndex <= (lineTokens.length - 1)
      if (headingTokenIndex < 0 || !headingContentsTokenExists) {
        return
      }
      const headingToken = lineTokens[headingTokenIndex]
      const headingContentsToken = lineTokens[headingContentsTokenIndex]
      if (headingToken.end === headingContentsToken.start) {
        addTypeToToken(headingContentsToken, 'mw-section-header-text')
        addTypeToToken(headingContentsToken, `mw-section-header-depth-${headingContentsToken.start}`)
      }
    }

    const addTypeToToken = (token, type) => {
      if (token.type === null) {
        token.type = type
      } else {
        let types = token.type.split(' ')
        types.push(type)
        token.type = types.join(' ')
      }
    }

    const lineTokensFromTokenAtIndex = (lineTokens, index) => {
      return lineTokens.filter((token, thisIndex) => thisIndex >= index)
    }
    
    const enrichListTokens = (lineTokens) => {
      const soughtTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-list')
      if (soughtTokenIndex < 0) {
        return
      }      
      const soughtToken = lineTokens[soughtTokenIndex]
      const supplementToken = (token) => {
        addTypeToToken(token, `mw-list-depth-${soughtToken.end}`)
        addTypeToToken(token, soughtToken.string.includes('#') ? `mw-list-ordered` : `mw-list-unordered`)
      }
      lineTokensFromTokenAtIndex(lineTokens, soughtTokenIndex)
        .forEach(supplementToken)
    }

    const enrichIndentTokens = (lineTokens) => {
      const soughtTokenIndex = indexOfFirstLineTokenWithType(lineTokens, 'mw-indenting')
      if (soughtTokenIndex < 0) {
        return
      }      
      const soughtToken = lineTokens[soughtTokenIndex]
      const supplementToken = (token, index) => {
        if (index > 0) {
          addTypeToToken(token, `mw-indenting-contents`)
        }
        addTypeToToken(token, `mw-indenting-depth-${soughtToken.end}`)
      }
      lineTokensFromTokenAtIndex(lineTokens, soughtTokenIndex)
        .forEach(supplementToken)
    }

    const enrichSignatureTokens = (lineTokens) => {
      const supplementToken = (token) => {
        addTypeToToken(token, `mw-signature-depth-${token.end - token.start}`)
      }
      lineTokens
        .filter(token => {
          return tokenIncludesType(token, 'mw-signature')
        })
        .forEach(supplementToken)
    }

    const arraysAreEqual = (a1, a2) => {
      if (a1.length !== a2.length) {
        return false
      }
      let i = a1.length
      while (i--) {
          if (a1[i] !== a2[i]) return false
      }
      return true
    }
    
    
    
    
    
    
// instead of enriching tokens should this helper have a method for getting type info out of token, but the method would enrich
// the retrieved types?    
    class TokenHelper {
      constructor(token, selectionRange) {
        this.token = token
        this.selectionRange = selectionRange
      }
      types() {
        if (this.token.type === null) {
          return []
        }
        return this.token.type
          .split(' ')
          .filter(s => s.trim().length > 0)
      }
      includesType(type) {
        return this.types().includes(type) 
      }
      intersectsSelection() {
        if (!this.selectionRange.isSingleLine) {
          return false
        }
        return rangesIntersect(this.selectionRange, this.token)
      }
      includesSelection() {
        if (this.token.string === null) {
          return false
        }
        return this.token.string.includes(this.selectionRange.selection)
      }
    }
    
    
    
    
    const singleDeepFlatten = a => [].concat(...a)
    
    
    const selectedButtons = (doc) => {  
      const selection = doc.getSelection()
      const multipleCharactersSelected = selection.length > 0
      const selectionRange = getSelectionRange(doc)
      const lineTokens = enrichedLineTokens(doc, selectionRange.line)
      
      // For now only supports single line selection ranges.
      const intersectingTokens = selectionRange.isSingleLine ? tokensIntersectingSelection(selectionRange, lineTokens) : []
      const typesArray = intersectingTokens.map(token => token.type)
        .join(' ')
        .split(' ')
        .filter(s => {
          return s.trim().length > 0
        })
      
      let result = []
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      // if (
      //   arraysAreEqual(typesArray, ['mw-apostrophes-bold', 'strong', 'mw-apostrophes-bold']) ||
      //   arraysAreEqual(typesArray, ['mw-apostrophes-bold', 'strong']) ||
      //   arraysAreEqual(typesArray, ['strong']) ||
      //   arraysAreEqual(typesArray, ['strong', 'mw-apostrophes-bold'])
      // ) {
      // 

const lineTokenHelpers = lineTokens.map(t => new TokenHelper(t, selectionRange))
const lineTokenHelpersIntersectingSelection = lineTokenHelpers.filter(th => th.intersectsSelection())
/*
const lineTokenHelpersIntersectingSelection2 = lineTokenHelpersIntersectingSelection
  .filter((th, index, array) => {
    // if (selectionRange.end - selectionRange.start > 0) {
    //   if (index === 0 || index === array.length - 1) {
    //     return th.token.end !== selectionRange.start && th.token.start !== selectionRange.end
    //   }
    // }
    
// if (selectionRange.end - selectionRange.start === 0) {
//   return true
// }
// if (index === 0 && th.token.end === selectionRange.start) {
//   return false
// }
// if (index === array.length - 1 && th.token.start === selectionRange.end) {
//   return false
// }

return !th.includesType('mw-apostrophes-bold')

    
    
    return true
  })
*/
  
  

//const aaa = lineTokenHelpersIntersectingSelection.map(th => th.types())
const intersectingTokensTypesArray = singleDeepFlatten(lineTokenHelpersIntersectingSelection.map(th => th.types()))


//const selectionHasOnlyOneType = (new Set(intersectingTokensTypesArray).size) === 1

// const everyLineTokenHelperIntersectingSelectionHasType = (type) => {
//   for (th of lineTokenHelpersIntersectingSelection) {
//     if (!th.includesType(type)) {
//       return false
//     }
//   }
//   return true
// }

// }



// EASIEST "no-boundaries crossed" check??? 
// - ensure only 1 'strong' in typesArray
// - ensure 'doc.getSelection()' string is a substring of the 'strong' token string
/*
const onlyOneLineTokenHelperOfTypeIntersectsSelection = (type) => {
  const lineTokenHelpersOfTypeIntersectingSelection = lineTokenHelpersIntersectingSelection.filter(th => th.includesType(type))
  if (lineTokenHelpersOfTypeIntersectingSelection.length !== 1) {
    return false
  }
  return lineTokenHelpersOfTypeIntersectingSelection[0].includesSelection()
}
*/

// const containsOnly = (array1, array2) => {
//   if (array1.length === 0) {
//     return false
//   }
//   return array1.every(elem => array2.includes(elem))
// }

const intersectingTokensTypesArray2 = intersectingTokensTypesArray.filter(s => {
  return true //!s.startsWith('mw-')
})
const intersectingTokensTypesArray3 = Array.from(new Set(intersectingTokensTypesArray2))


if (intersectingTokensTypesArray3.includes('strong')) {
  // if (containsOnly(intersectingTokensTypesArray, ['mw-apostrophes-bold', 'strong'])) {
    result.push(buttonPayload('bold'))
  // }
}

if (intersectingTokensTypesArray3.includes('em')) {
    result.push(buttonPayload('italic'))
}









/*
      let strongTokens = intersectingTokens.filter(t => {
        const type = t.type
        if (type === null) {
          return false
        }
        return type.includes('strong')
      })
      if (strongTokens.length === 1) {
        const strongToken = strongTokens[0]
        if (strongToken.string.includes(selection)) {
          result.push(buttonPayload('bold'))          
        }
      }
*/


/*
      if (typesArray.includes('strong')) {
        
// EASIEST "no-boundaries crossed" check??? 
// - ensure only 1 'strong' in typesArray
// - ensure 'doc.getSelection()' string is a substring of the 'strong' token string
// - if works generalize for other wikitext types?        
        result.push(buttonPayload('bold'))
      }
*/
      // if (typesArray.includes('em')) {
      //   result.push(buttonPayload('italic'))
      // }
      if (typesArray.includes('mw-link-ground')) {
        result.push(buttonPayload('link'))
      }
      if (typesArray.includes('mw-tag-ref') || typesArray.includes('mw-ext-ref')) {
        result.push(buttonPayload('reference'))
      }
      if (typesArray.includes('mw-template-ground')) {
        result.push(buttonPayload('template'))
      }
      if (typesArray.includes('mw-comment')) {
        result.push(buttonPayload('comment'))
      }
      if (typesArray.includes('mw-section-header-text')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-section-header-depth-')
        result.push(buttonPayload('heading', {depth: depth}))
      }
      if (typesArray.includes('mw-list-ordered') || typesArray.includes('mw-list-unordered')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-list-depth-')
        const ordered = typesArray.includes('mw-list-ordered')
        result.push(buttonPayload('li', {depth: depth, ordered: ordered}))
      }
      if (typesArray.includes('mw-indenting') || typesArray.includes('mw-indenting-contents')) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-indenting-depth-')
        result.push(buttonPayload('indent', {depth: depth}))
      }
      if (typesArray.includes('mw-signature')/* || typesArray.includes('mw-signature-contents')*/) {
        const depth = numberFromPrefixedKey(typesArray, 'mw-signature-depth-')
        result.push(buttonPayload('signature', {depth: depth}))
      }





/*
const boldContentsToken = editor.getLineTokens(selectionRange.line, true)
  .filter(t => {
    return (selectionRange.start >= t.start && selectionRange.end <= t.end)
  }) //THIS ^ is wrong! returns and array but below we assume it's a string
const boldContentsTokenString = boldContentsToken.string
const intersectingTokensString = intersectingTokens.map(t => {
  return (t.string !== null) ? t.string : ''  
})
*/




      result.push(buttonPayload('debug', {
         tokensIntersectingSelectionStrings: intersectingTokens.map(token => token.string).join(''),
         // tokensIntersectingSelectionTypesArray: typesArray,
         selectionRange: getSelectionRange(doc),
         getSelectionText: selection,
         tokensIntersectingSelectionTypesArray2: intersectingTokensTypesArray,
         intersectingTokensTypesArray3: intersectingTokensTypesArray3
         // aaa: aaa
         // z_boldContentsTokenString: boldContentsTokenString,
         // z_intersectingTokensString: intersectingTokensString
       }
      ))
     
      const historySize = doc.historySize()
      if (historySize.undo > 0) {
        result.push(buttonPayload('undo'))
      }
      if (historySize.redo > 0) {
        result.push(buttonPayload('redo'))
      }
        
      return result
    }

    const sendNativeMessages = (doc) => {
      // sends message to native land that selection has changed,
      // upon receipt native land should de-select all buttons
      const selectionRange = getSelectionRange(doc)
      const isSelectionMoreThanOneChar = !selectionRange.isSingleLine || (selectionRange.end - selectionRange.start) > 0
      window.webkit.messageHandlers.selectionChanged.postMessage(isSelectionMoreThanOneChar)

      // sends message to native land about which buttons should be selected,
      // native land should assume only these buttons should appear selected
      window.webkit.messageHandlers.highlightTheseButtons.postMessage(selectedButtons(doc))
    }


    let savedCursorState = null
    
    const clearSavedCursorState = () => {
      savedCursorState = null
    }
    
    const saveCursorState = () => {
      savedCursorState = {
        anchor: editor.getCursor('anchor'),
        head: editor.getCursor('head')
      }
    }

    const restoreCursorState = () => {
      if (savedCursorState.anchor !== null && savedCursorState.head !== null) { 
        editor.setSelection(savedCursorState.anchor, savedCursorState.head)
      }
     clearSavedCursorState()
    }


    const showCodemirror = () => {
      editor = CodeMirror.fromTextArea(editorTextArea, codeMirrorSettings)
      editorTextArea.style.display = 'hidden'
      currentEditorType = EditorType.codemirror
      editor.on('cursorActivity', sendNativeMessages)
      editor.on('blur', () => {
        saveCursorState()
      })
      editor.on('focus', () => {
        setTimeout(()=> {
          restoreCursorState()      
        }, 10)
      })
    }
    
    const wmf = {}
    
    wmf.EditorType = EditorType
    
    wmf.getWikitext = () => {
      switch(currentEditorType) {
        case EditorType.codemirror:
          return editor.getValue()  
        case EditorType.wikitext:
          return editorTextArea.value
      }
    }

    wmf.setWikitext = (wikitext) => {
      switch(currentEditorType) {
        case EditorType.codemirror:
          editor.setValue(wikitext)
          break
        case EditorType.notset:
        case EditorType.wikitext:
          editorTextArea.value = wikitext
          break
      }
    }

    wmf.setCurrentEditorType = (type) => {
      currentEditorType = type
    }

    wmf.update = () => {
      clearSavedCursorState()
      switch(currentEditorType) {
        case EditorType.codemirror:
          showCodemirror()
          break
        case EditorType.notset:
        case EditorType.wikitext:
          showWikitext()
          break
      }
    }

    const isButtonSelected = (buttonType) => selectedButtons(editor).filter((item) => {return item.button === buttonType}).length > 0
    wmf.commands = {
      focus: () => {
        editor.focus()
      },
      undo: () => editor.undo(),
      redo: () => editor.redo(),
      cursorUp: () => editor.execCommand('goLineUp'),
      cursorDown: () => editor.execCommand('goLineDown'),
      cursorLeft: () => editor.execCommand('goCharLeft'),
      cursorRight: () => editor.execCommand('goCharRight'),
      bold: () => {
        const isOn = isButtonSelected('bold')
        if (isOn) {


          
          // const boldContentsToken = editor.getLineTokens(editor.getCursor().line, true).filter(t => {return (editor.getCursor('from').ch >= t.start && editor.getCursor('to').ch <= t.end )})
// compare boldContentsToken 'string' to string from all tokens in tokensIntersectingSelection
// ^ BUT we should probably do this up above as easier way to see if bold button should be enabled.

          
          
          console.log('asdf')
// can enrichment be modified to make it easier to turn off bold?
// `isButtonSelected` ends up calling the code which enriches copies of current line tokens... they are copies
// but maybe we can inspect the enriched tokens identifying relevants ones, then use their indices to get `live`
// line tokens of respective indices...
// 
// pass enriched line tokens to `selectedButtons` so we can use/inspect them here w/o calling `selectedButtons`? 
// experiment with further enrichment? 
// but do remember we're gonna have to something like this to actually replace things... i think... :
// 		var pos = editor.getCursor() // or {line , ch };
//		var tok = editor.getTokenAt(pos);
//		editor.replaceRange("string", {line: pos.line , ch:tok.start},{line:pos.line , ch:tok.end});


          
          // editor.replaceSelection(`''' '''`)
          // editor.execCommand('goCharLeft')
          // editor.execCommand('goCharLeft')
          // editor.execCommand('goCharLeft')
          // editor.execCommand('goCharLeft')
          // const cursor = editor.getCursor()
          // editor.extendSelection(cursor, {line: cursor.line, ch: cursor.ch + 1})
        } else {

        }
      },
      italic: () => {
        console.log('italic')
      },
      reference: () => {
        console.log('reference')
      },
      template: () => {
        console.log('template')
      },
      anchor: () => {
        console.log('anchor')
      },
      indent: () => {
        console.log('indent')
      },
      signature: () => {
        console.log('signature')
      },
      list: () => {
        console.log('list')
      },
      heading: () => {
        console.log('heading')
      },
      increaseIndentDepth: () => {
        console.log('increaseIndentDepth')
      },
      decreaseIndentDepth: () => {
        console.log('decreaseIndentDepth')
      }
    }
    
    window.wmf = wmf

  </script>
</body>
