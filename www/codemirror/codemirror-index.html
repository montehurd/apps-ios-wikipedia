
<!doctype html>
<meta charset=utf8>
<meta name="viewport" id="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
<script src="resources/lib/codemirror/lib/codemirror.js"></script>
<link rel=stylesheet href="resources/lib/codemirror/lib/codemirror.css">
<script src="resources/mode/mediawiki/mediawiki.js"></script>
<link rel=stylesheet href="resources/mode/mediawiki/mediawiki.css">

<style>
  
  body {
    margin: 0;
  }
  
  .CodeMirror, textarea#editor {
    height: 100vh;
    width: 100%;
    -webkit-overflow-scrolling: touch;
    box-sizing: border-box;
  }
  
  textarea#editor {
    padding: 4px;
    border: none;
    font-family: monospace;
    font-size: 13px;
  }
  
</style>

<body>
  
  <textarea id=editor></textarea>


  <!--TODO: load config by lang as needed-->
  <script>
  let config
  </script>
  <script src="codemirror-config.js" ></script>


  <script>

    let editor
    let editorTextArea = document.getElementById("editor")
    
    let codeMirrorSettings = {
      mwConfig: config,
      lineWrapping: true,
      lineNumbers: true,
      mode: "text/mediawiki",
      matchBrackets: true,
      extraKeys: {
        // t.b.d.
      }, 
      inputStyle: 'contenteditable',
      spellcheck: false,
      viewportMargin: Infinity
    }

    const EditorType = {
      notset: 0,
      codemirror: 1,
      wikitext: 2
    }

    let currentEditorType = EditorType.notset

    const showWikitext = () => {
      editor.toTextArea()
      editorTextArea.style.display = 'block'
      currentEditorType = EditorType.wikitext
    }

const selectedButtons = (doc) => {  
  const selection = doc.getSelection()

  // TODO: fix button determination logic below to work when range of text selected
  if (selection.length > 0) {
    return
  }
  
  const cursorHead = doc.getCursor('head')
  const tokenType = doc.getTokenTypeAt(cursorHead)
  let result = []

  /*
  if (tokenType) {
    result.push(tokenType)
  }
  */
  if (tokenType) {
    if (tokenType.includes(' strong') || tokenType === 'mw-apostrophes-bold') {
      result.push('bold')
    }
    if (tokenType.includes(' em') || tokenType === 'mw-apostrophes-italic') {
      result.push('italic')
    }
    if (tokenType.includes('mw-link-')) {
      result.push('link')
    }
    if (tokenType.includes('mw-tag-ref') ||  tokenType.includes('mw-ext-ref')) {
      result.push('reference')
    }
    if (tokenType.includes('mw-template-')) {
      result.push('template')
    }
    if (tokenType.includes('mw-comment')) {
      result.push('comment')
    }
    
    /*
    // To use this would need to include my hack changes to 'mediawiki.js'.
    // The 'firstTokenOfLine' with 'messageForSymbol' approach seems to work ok for now...
    if (tokenType.includes('mw-section-header-equals-') || tokenType.includes('mw-section-header-text-')) {
      const parts = tokenType.split('-')
      const hNumber = parts[parts.length - 1]
      result.push('h' + hNumber)
    }
    */
  }



  /*
  instead of the header hack which requires a modification to the mediawiki.js file, can i instead
  use 'getTokenAt: function(pos, precise)' for the first char of the line of the selection?

  in theory could work for not only for headers but also OL, UL and indent!

  */
  // const firstCharOfLineTokenType = doc.getTokenTypeAt({line: cursorHead.line, ch: 0})
  // if (firstCharOfLineTokenType) {
  //   result.push(`firstCharOfLineTokenType = ${firstCharOfLineTokenType}`)


  // returns zero if `string` is not comprised only of `char`.
  // else returns length of `string`
  const charCountInString = (string, char) => {
    const matches = string.match(`^${char}+$`)
    return (matches === null) ? 0 : string.length
  }

  // determine message to send for headings, list items, indents and signatures
  const messageForSymbol = (symbol) => {
    // '=' 1-6
    const equalsCount = charCountInString(symbol, '=')
    if (equalsCount > 0 && equalsCount < 7) {
      return {item: 'heading', depth: equalsCount}
    }

    // '*' 1-n
    const starCount = charCountInString(symbol, "\\*")
    if (starCount > 0) {
      return {item: 'ul li', depth: starCount}
    }

    // '#' 1-n
    const hashCount = charCountInString(symbol, '#')
    if (hashCount > 0) {
      return {item: 'ol li', depth: hashCount}
    }
    
    // ':' 1-n
    const colonCount = charCountInString(symbol, ':')
    if (colonCount > 0) {
      return {item: 'indent', depth: colonCount}
    }
    
    // '~' 3-4 (FIX: should probably work if there's leading spaces on the line -  would need to see if string has leading whitespace and look at token just after that whitespace...)
    const tildeCount = charCountInString(symbol, '~')
    if (tildeCount === 3 || tildeCount === 4) {
      return {item: 'signature', depth: tildeCount}
    }

    return null
  }

  const firstTokenOfLine = doc.getTokenAt({line: cursorHead.line, ch: 1})
  if (firstTokenOfLine) {
    const msg = messageForSymbol(firstTokenOfLine.string)
    if (msg) {
      result.push(msg)
    }
    // result.push(`symbol = '${symbol}'`)
  }
    











/*
- need to somehow check in the code i pulled from carthage so we can commit the change i made 
  to fix header determination. (copy of the file on desktop in case i blast changes)
- create fork on wikimedia GH and push changes to it - then pull that repo instead
*/


  return result
}

const emitSelectedButtons = (doc) => {
  // sends message to native land about which buttons should be selected,
  // native land should assume only these buttons should appear selected
  window.webkit.messageHandlers.selectedButtons.postMessage(selectedButtons(doc))
}


/*
    const sendCursorActivityMessages = (doc) => {
      let cursorHead = doc.getCursor('head')
      let cursorFrom = doc.getCursor('from')
      let cursorTo = doc.getCursor('to')
      let cursorAnchor = doc.getCursor('anchor')
      
      const tokenInfo = (token) => {
        return {
          'start': token.start,
          'end': token.end,
          'string': token.string,
          'type': token.type
        }
      }
      
      const msg = (cursor) => {
        return {
          'line': cursor.line,
          'ch': cursor.ch,
          'tokenType': doc.getTokenTypeAt(cursor),
          'tokenInfo': tokenInfo(doc.getTokenAt(cursor))
        }
      }
      
// TODO: decide whether to interpret token info etc here before messaging native land...
// if so, don't send all the getCursor details, but rather an interpretation of what state
// should be reported - i.e. if the cursor selection extends over text which has bold AND
// unbold parts, report that the bold button should show as disabled. Each button type 
// will own such state heuristics.

      window.webkit.messageHandlers.cursorActivity.postMessage({
        'head': msg(cursorHead),
        'from': msg(cursorFrom),
        'to': msg(cursorTo),
        'anchor': msg(cursorAnchor),
        'selections': doc.getSelection()
      })
    }
*/
    const showCodemirror = () => {
      editor = CodeMirror.fromTextArea(editorTextArea, codeMirrorSettings)
      editorTextArea.style.display = 'hidden'
      currentEditorType = EditorType.codemirror
      //editor.on('cursorActivity', sendCursorActivityMessages)
      editor.on('cursorActivity', emitSelectedButtons)
    }
    
    const wmf = {}
    
    wmf.EditorType = EditorType
    
    wmf.getWikitext = () => {
      switch(currentEditorType) {
        case EditorType.codemirror:
          return editor.getValue()  
        case EditorType.wikitext:
          return editorTextArea.value
      }
    }

    wmf.setWikitext = (wikitext) => {
      switch(currentEditorType) {
        case EditorType.codemirror:
          editor.setValue(wikitext)
          break
        case EditorType.notset:
        case EditorType.wikitext:
          editorTextArea.value = wikitext
          break
      }
    }

    wmf.setCurrentEditorType = (type) => {
      currentEditorType = type
    }

    wmf.update = () => {
      switch(currentEditorType) {
        case EditorType.codemirror:
          showCodemirror()
          break
        case EditorType.notset:
        case EditorType.wikitext:
          showWikitext()
          break
      }
    }

    wmf.ExecCommandType = {
      cursorUp: 'goLineUp',
      cursorDown: 'goLineDown',
      cursorLeft: 'goCharLeft',
      cursorRight: 'goCharRight',
      undo: 'undo',
      redo: 'redo'
    }

    wmf.execCommand = (execCommandType) => {
      editor.execCommand(execCommandType)
    }

    window.wmf = wmf

  </script>
</body>